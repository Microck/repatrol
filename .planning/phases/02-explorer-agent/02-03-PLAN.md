---
phase: 02-explorer-agent
plan: 03
type: execute
wave: 3
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/agents/explorer_agent.py
  - src/agents/__init__.py
  - src/core/run_context.py
  - src/core/__init__.py
  - scripts/run_explorer.py
autonomous: true

must_haves:
  truths:
    - "Explorer can run for N steps without getting stuck"
    - "Explorer discovers multiple distinct screen_ids and updates coverage"
  artifacts:
    - path: "src/agents/explorer_agent.py"
      provides: "Explorer agent loop (observe -> decide -> act)"
      contains: "class ExplorerAgent"
    - path: "scripts/run_explorer.py"
      provides: "Run Explorer against target game"
      contains: "--steps"
  key_links:
    - from: "src/agents/explorer_agent.py"
      to: "src/automation/browser.py"
      via: "BrowserGameDriver"
      pattern: "BrowserGameDriver"
    - from: "src/agents/explorer_agent.py"
      to: "src/vision/foundry_vision.py"
      via: "state_from_screenshot"
      pattern: "state_from_screenshot"
    - from: "src/agents/explorer_agent.py"
      to: "src/models/coverage.py"
      via: "CoverageTracker.observe"
      pattern: "CoverageTracker"
---

<objective>
Implement the Explorer agent: a loop that uses screenshots + vision state to choose actions that increase coverage.

Purpose: Deliver systematic exploration behavior for the core demo.
Output: `ExplorerAgent` + runnable CLI.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/automation/browser.py
@src/vision/foundry_vision.py
@src/models/coverage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add core RunContext for artifact paths + shared utilities</name>
  <files>
src/core/__init__.py
src/core/run_context.py
  </files>
  <action>
Create a `RunContext` object shared by agents.

- Include `run_id`, `artifacts_dir`, and references to shared services (llm client, recorder/driver handles if needed).
- Centralize artifact subdirectories so Explorer/Chaos/Reporter are consistent.
- Keep it simple: dataclass + helper methods (no heavy framework).
  </action>
  <verify>
python3 -m compileall src
python3 -c "from src.core.run_context import RunContext; print(RunContext)"
  </verify>
  <done>
Core run context exists and can be imported by agents.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ExplorerAgent policy loop + CLI runner</name>
  <files>
src/agents/__init__.py
src/agents/explorer_agent.py
scripts/run_explorer.py
  </files>
  <action>
Implement the Explorer in a way that is deterministic enough to demo.

- Define `ExplorerAgent.run(steps: int)` performing:
  1) capture screenshot
  2) call vision -> `GameState`
  3) update `CoverageTracker`
  4) select next action (prefer actions not seen yet; else random among hints)
  5) execute action via `BrowserGameDriver`
- Add anti-stuck heuristics:
  - if `screen_id` repeats > K times, try a "back" / "escape" / random click fallback.
  - if `is_loading` true, wait with timeout.
- `scripts/run_explorer.py` should:
  - accept `--steps`, `--headless`, `--out artifacts/coverage.json`
  - print a final coverage summary.
  </action>
  <verify>
python3 scripts/run_explorer.py --help
python3 -m compileall src
  </verify>
  <done>
Explorer runner exists and prints coverage summary; the agent loop uses state + coverage to drive actions.
  </done>
</task>

</tasks>

<verification>
- Running with `--steps 50` creates `artifacts/coverage.json` and reports >1 distinct screen_id on a non-trivial game.
</verification>

<success_criteria>
- EXPL-01 and EXPL-04 unblocked: Explorer navigates systematically and discovers distinct screens.
</success_criteria>

<output>
After completion, create `.planning/phases/02-explorer-agent/02-03-SUMMARY.md`
</output>
