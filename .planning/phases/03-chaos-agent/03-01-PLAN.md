---
phase: 03-chaos-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/detection/crash.py
  - src/detection/hang.py
  - src/detection/__init__.py
  - scripts/detection_smoke.py
autonomous: true

must_haves:
  truths:
    - "The system can detect likely crashes via browser/page signals"
    - "The system can detect hangs based on timeouts and lack of state change"
  artifacts:
    - path: "src/detection/crash.py"
      provides: "Crash detection from Playwright errors + page signals"
      contains: "class CrashDetector"
    - path: "src/detection/hang.py"
      provides: "Hang detection using state repetition + wall-clock timeout"
      contains: "class HangDetector"
    - path: "scripts/detection_smoke.py"
      provides: "Smoke tests for detectors (mocked inputs)"
      contains: "--mode"
  key_links:
    - from: "src/detection/crash.py"
      to: "playwright"
      via: "page.on('pageerror'|'crash') / exceptions"
      pattern: "pageerror"
---

<objective>
Implement crash + hang detection primitives that Chaos can use to recognize failures and trigger evidence capture.

Purpose: Without reliable detection, Chaos just spams inputs with no signal.
Output: Detector modules + smoke harness.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/vision/game_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CrashDetector and HangDetector with clear signals</name>
  <files>
src/detection/__init__.py
src/detection/crash.py
src/detection/hang.py
  </files>
  <action>
Implement two simple detectors.

- `CrashDetector` should detect:
  - Playwright navigation errors / page crashes / unhandled page errors
  - HTTP 5xx bursts (if accessible)
  - console messages matching a small allowlist of "fatal" patterns (configurable)
- `HangDetector` should detect:
  - no change in `GameState.screen_id` for > T seconds (or > N steps)
  - repeated `is_loading=true` beyond a timeout
- Keep the interface minimal:
  - `observe(state, now)` updates internal counters
  - `check()` returns None or a structured reason string.
  </action>
  <verify>
python3 -m compileall src
python3 -c "from src.detection.crash import CrashDetector; from src.detection.hang import HangDetector; print(CrashDetector, HangDetector)"
  </verify>
  <done>
Detectors exist, import cleanly, and expose a stable observe/check API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add detector smoke harness with mocked state streams</name>
  <files>
scripts/detection_smoke.py
  </files>
  <action>
Create a smoke runner that validates the detectors trigger when they should.

- Implement scenarios:
  - "hang": repeated same `screen_id` for N steps triggers hang
  - "crash": injected pageerror/exception triggers crash
- Keep it offline: no real browser required; mock observations.
  </action>
  <verify>
python3 scripts/detection_smoke.py --mode hang
python3 scripts/detection_smoke.py --mode crash
  </verify>
  <done>
Smoke runner exits 0 and prints the triggered reason for each scenario.
  </done>
</task>

</tasks>

<verification>
- Detectors are callable from agent loops without needing a real browser.
</verification>

<success_criteria>
- CHAOS-03 unblocked: hang/crash detection primitives exist.
</success_criteria>

<output>
After completion, create `.planning/phases/03-chaos-agent/03-01-SUMMARY.md`
</output>
