---
phase: 03-chaos-agent
plan: 03
type: execute
wave: 2
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - src/agents/chaos_agent.py
  - src/agents/__init__.py
  - src/detection/crash.py
  - scripts/run_chaos.py
autonomous: true

must_haves:
  truths:
    - "Chaos can execute adversarial action sequences against the game"
    - "On crash/hang detection, Chaos writes a BugReport to disk with evidence"
  artifacts:
    - path: "src/agents/chaos_agent.py"
      provides: "Chaos agent loop + adversarial action generator"
      contains: "class ChaosAgent"
    - path: "scripts/run_chaos.py"
      provides: "Run Chaos against the target game"
      contains: "--duration"
  key_links:
    - from: "src/agents/chaos_agent.py"
      to: "src/detection/crash.py"
      via: "CrashDetector"
      pattern: "CrashDetector"
    - from: "src/agents/chaos_agent.py"
      to: "src/models/bug.py"
      via: "BugReport"
      pattern: "BugReport"
---

<objective>
Implement Chaos agent adversarial testing with detection-triggered bug capture.

Purpose: Find real bugs by stressing edge cases and recognizing failure modes.
Output: `ChaosAgent` + CLI runner that emits `artifacts/bugs/*.json`.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/automation/browser.py
@src/vision/foundry_vision.py
@src/detection/crash.py
@src/detection/hang.py
@src/models/bug.py
@src/evidence/capture.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement adversarial action generator (rapid clicks, weird inputs)</name>
  <files>
src/agents/chaos_agent.py
src/agents/__init__.py
  </files>
  <action>
Implement a small set of adversarial actions with configurable intensity.

- Actions should include:
  - rapid clicking bursts
  - random clicking around the viewport
  - spam key presses / long strings (where text input exists)
  - repeated open/close (escape/back) if relevant
- Keep action API explicit (list of callables or enum + params); avoid a huge DSL.
  </action>
  <verify>
python3 -m compileall src
python3 -c "from src.agents.chaos_agent import ChaosAgent; print(ChaosAgent)"
  </verify>
  <done>
ChaosAgent module imports and exposes a clear list of adversarial actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Attach CrashDetector to real Playwright page events during Chaos runs</name>
  <files>
src/detection/crash.py
src/agents/chaos_agent.py
  </files>
  <action>
Make crash detection work in real browser runs by wiring Playwright page signals into `CrashDetector`.

- Add an explicit method on `CrashDetector` (or a tiny helper function) like `attach(page)` that registers listeners:
  - `page.on('pageerror', ...)`
  - `page.on('crash', ...)` (if supported)
  - `page.on('console', ...)` (capture fatal patterns)
- Ensure these listeners update CrashDetector internal state so `check()` can return a reason string even if the run loop is still executing.
- In `ChaosAgent` startup, call `crash_detector.attach(page)` right after the page is created/navigated, before any actions.

This task is intentionally separate from detector implementation: it proves the critical wiring exists.
  </action>
  <verify>
python3 -m compileall src
  </verify>
  <done>
ChaosAgent attaches CrashDetector to the Playwright page and crash signals are observable via `CrashDetector.check()`.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire detection + evidence capture + BugReport output; add CLI runner</name>
  <files>
 src/agents/chaos_agent.py
 scripts/run_chaos.py
  </files>
  <action>
Integrate crash/hang detection into the Chaos run loop.

- In the run loop:
  - after each action, capture screenshot -> state -> observe detectors
  - ensure video recording is enabled for real runs (Playwright context created with `record_video_dir` via `SessionRecorder.attach_to_context(...)`).
  - if detector triggers:
    - call `capture_bug_evidence(...)`
    - finalize recording (`SessionRecorder.finalize(...)`) to get the actual video file path
    - build `BugReport` including `evidence.video_path`
    - save under `artifacts/bugs/{bug_id}.json`
    - stop (for demo determinism).
- `scripts/run_chaos.py`:
  - accepts `--duration-seconds` or `--steps`
  - prints location of the saved bug report when triggered
  - returns exit code 2 when a bug is found (so orchestrator can treat as success).
  </action>
  <verify>
python3 scripts/run_chaos.py --help
python3 -m compileall src
  </verify>
  <done>
Chaos run produces a bug JSON + evidence artifacts when detectors trigger.
  </done>
</task>

</tasks>

<verification>
- On a deliberately buggy target game, Chaos finds a failure and writes `artifacts/bugs/*.json`.
</verification>

<success_criteria>
- CHAOS-01 and CHAOS-02 unblocked: Chaos sends random/adversarial inputs and attempts edge cases.
</success_criteria>

<output>
After completion, create `.planning/phases/03-chaos-agent/03-03-SUMMARY.md`
</output>
