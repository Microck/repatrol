---
phase: 01-foundation
plan: 01
type: execute
wave: 2
depends_on:
  - "01-04"
files_modified:
  - requirements.txt
  - src/config/target_game.py
  - src/config/__init__.py
  - src/automation/browser.py
  - src/automation/__init__.py
  - scripts/run_smoke.py
autonomous: true

must_haves:
  truths:
    - "A script can open the target web game and take a screenshot"
    - "The automation layer can click and type in the game page"
    - "Smoke verification does not require a manually-started local demo server"
  artifacts:
    - path: "requirements.txt"
      provides: "Python deps for browser automation"
      contains: "playwright"
    - path: "src/automation/browser.py"
      provides: "Playwright-backed browser driver for game control"
      contains: "class BrowserGameDriver"
    - path: "src/config/target_game.py"
      provides: "Target game URL + selectors / coordinate config"
      contains: "TARGET_GAME_URL"
    - path: "scripts/run_smoke.py"
      provides: "Smoke run: open game, click/type, screenshot"
      contains: "def main"
  key_links:
    - from: "scripts/run_smoke.py"
      to: "src/automation/browser.py"
      via: "BrowserGameDriver"
      pattern: "BrowserGameDriver"
    - from: "src/automation/browser.py"
      to: "playwright"
      via: "sync_playwright"
      pattern: "sync_playwright"
---

<objective>
Stand up a minimal Python + Playwright automation layer that can open a target web game, send basic inputs, and capture a screenshot.

Purpose: Provide the hard foundation every agent will rely on (control + observability).
Output: Playwright-based driver + smoke script.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@../../plans/stream-qa-swarm.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bootstrap Python runtime deps and config scaffold</name>
  <files>
requirements.txt
src/config/__init__.py
src/config/target_game.py
  </files>
  <action>
Create a minimal dependency set for v1 and a target game config module.

- Add `playwright` plus only the essentials for v1 modeling/CLI (keep it lean; prefer standard library).
 - Add `playwright` plus only the essentials for v1 modeling/CLI (keep it lean; prefer standard library).
 - Explicitly install Playwright's Chromium browser as part of setup (use `--with-deps` on Linux).
 - In `src/config/target_game.py`, define:
   - `TARGET_GAME_URL` (default to the in-repo demo game, served locally; use http://127.0.0.1:4173)
   - `DEFAULT_VIEWPORT` (width/height)
   - optional selectors (e.g. `GAME_CANVAS_SELECTOR`) as constants to avoid hardcoding later.
- Keep config override-friendly via environment variables (e.g. `os.getenv`).
  </action>
  <verify>
 python3 -m pip install -r requirements.txt
 python3 -m playwright install --with-deps chromium
 python3 -c "import playwright; import src.config.target_game as t; print(t.TARGET_GAME_URL)"
  </verify>
  <done>
`requirements.txt` installs cleanly, Playwright Chromium installs successfully, and `src/config/target_game.py` imports without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Playwright-backed game driver + smoke script</name>
  <files>
src/automation/__init__.py
src/automation/browser.py
scripts/run_smoke.py
  </files>
  <action>
Implement a small, boring driver API that future agents can depend on.

- In `src/automation/browser.py` implement `BrowserGameDriver` with:
  - `start(url, headless)` -> launches Chromium and navigates
  - `screenshot(path)` -> saves PNG
  - `click(selector_or_xy)` -> click either a CSS selector or x/y tuple
  - `type(text)` -> types text into the page (or focused element)
  - `close()` -> cleanup
- Prefer Playwright's browser automation (not PyAutoGUI) for web games.
 - In `scripts/run_smoke.py`, wire config -> driver to:
   - start/stop the local demo game server automatically when `--url` is not provided
     - serve `demo/buggy_web_game/` on an ephemeral port
     - set the effective URL to `http://127.0.0.1:{port}/`
     - ensure the server is always stopped (even on exceptions)
   - open the page (effective URL)
   - perform one click + optional typing
   - capture a timestamped screenshot under `artifacts/screenshots/`
   - exit with non-zero code if navigation fails.
  </action>
  <verify>
  python3 -m compileall src
  python3 scripts/serve_buggy_web_game.py --check
  python3 scripts/run_smoke.py --headless
  </verify>
  <done>
 Smoke script launches a browser, reaches the in-repo demo game, and writes a screenshot artifact without requiring a pre-running local server.
  </done>
</task>

</tasks>

<verification>
- `python3 scripts/run_smoke.py ...` produces `artifacts/screenshots/*.png`
- Driver API stays small (no framework-specific coupling beyond Playwright)
</verification>

<success_criteria>
 - FOUND-02, FOUND-03 partially unblocked: target game selected (local demo game) + URL configurable; click/type/screenshot works.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
